from fastapi import APIRouter, HTTPException
from fastapi.requests import Request
from fastapi.templating import Jinja2Templates
from pydantic import BaseModel, Field

from tools.user_input_jinja import (
    ALLOWED_TEXT_SECTIONS,
    add_input,
    add_table_row,
    add_template_text_entry,
    build_template_context,
    list_to_dict,
    load_template_input_data,
    set_template_metadata_value,
)

router = APIRouter()
templates = Jinja2Templates(directory="web")  # note this directory will need to be changed.


class TextEntryPayload(BaseModel):
    """
    Request model for adding a single text value into an ordered section list.

    This payload is used by endpoints that append entries to ``steps``,
    ``hazards``, or ``mitigations``.
    """

    entry: str = Field(..., min_length=1, description="Non-empty text value to append.")


class MetadataPayload(BaseModel):
    """
    Request model for setting one metadata key/value pair.

    Metadata keys are intended to map directly to named Jinja placeholders
    used by the Word document template (for example, ``project_name``).
    """

    field_name: str = Field(..., min_length=1, description="Metadata field key.")
    value: str = Field(..., description="Metadata field value.")


class TableRowPayload(BaseModel):
    """
    Request model for adding one complete table row to the template context.

    Each row aligns with the core table columns in the generated Word document:
    step description, hazard description, and mitigation description.
    """

    step: str = Field(..., min_length=1, description="Step text for the table row.")
    hazard: str = Field(..., min_length=1, description="Hazard text for the table row.")
    mitigation: str = Field(..., min_length=1, description="Mitigation text for the table row.")

@router.post("/api/add-user-input")
def add_item(entry: str):
    """
    Route to add user input to the user input list. User entries should be entered in the order they will eventually be displayed.

    :param entry: User input
    :type entry: str

    :return: Dictionary containing a list of user entries in order they were entered.
    """
    new = add_input(entry)  
    return {"input_list": new}


@router.get("/api/get-input-list")
def get_input(request: Request):
    """
    Render the legacy test template using indexed user input values.

    This route preserves the existing behavior used during initial backend
    testing. It converts list-based inputs into a dictionary keyed by string
    index values so placeholder-based Jinja rendering can be verified quickly.

    :param request: FastAPI request object required by ``TemplateResponse``.
    :type request: Request

    :return: Rendered HTML response for ``web/test.html``.
    """
    input_dict = list_to_dict()
    return templates.TemplateResponse(
        "test.html",
        {"request": request, "input_dict": input_dict})


@router.post("/api/template/steps")
def add_step(payload: TextEntryPayload):
    """
    Append one project step entry for later AI hazard analysis and document output.

    Steps are stored in insertion order because that order defines how rows should
    appear in the final safety table and keeps the AI processing pipeline aligned
    with user intent.

    :param payload: JSON body containing the step text to append.
    :type payload: TextEntryPayload

    :return: Dictionary containing updated ordered ``steps`` values.
    """
    updated_steps = add_template_text_entry("steps", payload.entry)
    return {"steps": updated_steps}


@router.post("/api/template/hazards")
def add_hazard(payload: TextEntryPayload):
    """
    Append one hazard entry to the hazards section used by Jinja document output.

    Hazard entries may be user-provided or generated by an AI agent from project
    steps. They are stored as an ordered list for deterministic rendering.

    :param payload: JSON body containing the hazard text to append.
    :type payload: TextEntryPayload

    :return: Dictionary containing updated ordered ``hazards`` values.
    """
    updated_hazards = add_template_text_entry("hazards", payload.entry)
    return {"hazards": updated_hazards}


@router.post("/api/template/mitigations")
def add_mitigation(payload: TextEntryPayload):
    """
    Append one mitigation entry to the mitigations section for template rendering.

    Mitigations are stored separately from hazards so you can support both
    independent section rendering and later row-level composition.

    :param payload: JSON body containing the mitigation text to append.
    :type payload: TextEntryPayload

    :return: Dictionary containing updated ordered ``mitigations`` values.
    """
    updated_mitigations = add_template_text_entry("mitigations", payload.entry)
    return {"mitigations": updated_mitigations}


@router.post("/api/template/metadata")
def set_metadata_value(payload: MetadataPayload):
    """
    Set a single metadata field/value pair for named Jinja placeholders.

    Use this route for non-list template fields like project title, author,
    revision, location, or any other scalar values shown in the final document.

    :param payload: JSON body with the metadata key and value.
    :type payload: MetadataPayload

    :return: Dictionary containing the full updated metadata object.
    """
    updated_metadata = set_template_metadata_value(payload.field_name, payload.value)
    return {"metadata": updated_metadata}


@router.post("/api/template/table-rows")
def add_template_table_row(payload: TableRowPayload):
    """
    Append one complete table row containing step, hazard, and mitigation values.

    This route supports direct table population when the client or agent already
    has finalized row-level values and wants to write them in one atomic request.

    :param payload: JSON body containing all three table column values.
    :type payload: TableRowPayload

    :return: Dictionary containing the updated ``table_rows`` list.
    """
    updated_rows = add_table_row(payload.step, payload.hazard, payload.mitigation)
    return {"table_rows": updated_rows}


@router.get("/api/template/section/{section_name}")
def get_template_section(section_name: str):
    """
    Return one stored section by name from the persisted template data payload.

    Supported section names are: ``metadata``, ``steps``, ``hazards``,
    ``mitigations``, and ``table_rows``.

    :param section_name: Name of the section to retrieve.
    :type section_name: str

    :return: Dictionary containing the requested section and its current value.
    :raises HTTPException: When the requested section name is not recognized.
    """
    valid_sections = {"metadata", "table_rows", *ALLOWED_TEXT_SECTIONS}
    if section_name not in valid_sections:
        raise HTTPException(
            status_code=400,
            detail=(
                "Invalid section_name. Supported values are "
                f"{sorted(valid_sections)}."
            ),
        )

    payload = load_template_input_data()
    return {section_name: payload[section_name]}


@router.get("/api/template/context")
def get_template_context():
    """
    Return the consolidated context object for Jinja-based Word document rendering.

    The response includes:
    - list-based data for easy loop rendering
    - indexed dictionaries for templates that use explicit index placeholders
    - metadata key/value fields

    :return: Complete template context dictionary ready for Jinja rendering.
    """
    return build_template_context()
